# 策略

## 迭代

利用循环重复一个过程，直到满足某个条件。  
循环中的每一步，都被称为迭代  
例：分别给出咸水鱼和淡水鱼的列表，两个列表中的鱼名均按字母顺序排列。创建一个包含所有鱼类的列表（鱼名按字母顺序排列）

```js
const list = [];
const seaFish = ["a", "d", "m"];
const freshFish = ["b", "c", "e", "o", "q"];
while (seaFish.length || freshFish.length) {
  if (!seaFish.length || seaFish[0] > freshFish[0]) {
    list.push(freshFish.shift());
  } else {
    list.push(seaFish.shift());
  }
}
```

## 递归

函数在定义中调用自身  
例：斐波那契数列；单词回文（单词被反转后是否保持不变）

递归算法在执行时会大量调用自身，从而引入计算开销。计算机必须跟踪未完成的递归调用及其部分计算，内存消耗将因此而增加。此外，从当前递归调用切换到下一个递归调用并返回也需要额外的 CPU 周期。

## 蛮力/穷举

## 回溯

例：八皇后问题。如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上

始终保持所有的后处于不会相互攻击的位置；一旦陷入困境，回滚到最后一个后的位置并重新选择

## 启发

### 贪心法

贪心法：尝试在每一步都做出最佳选择  
例：推销员必须到访 n 座给定的城市，并在旅程结束时回到出发地。哪种旅行计划能使旅行的总距离最短？  
(1) 到访最近一座未曾到访过的城市。  
(2) 重复上述步骤，直至到访所有城市

## 分治法

将问题分解为若干相似但更小的子问题；  
反复进行分解操作，直至子问题变得易于求解；  
将各个子问题的解合并在一起，即可得到原问题的解  
例：[归并排序](../algorithm/010_sort.md#归并排序)

## 动态规划

动态规划旨在找出重复的子问题，以便对每个子问题只计算一次  
比如斐波那契数，用一个 map 存储之前算过的和
