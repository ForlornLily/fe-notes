(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{305:function(a,t,s){a.exports=s.p+"assets/img/1c49abb6ea3d45284c9157c4f9f86a1f.1c49abb6.png"},306:function(a,t,s){a.exports=s.p+"assets/img/2ddfb1ce24a45af1d6d38ae3121739ab.2ddfb1ce.png"},307:function(a,t,s){a.exports=s.p+"assets/img/6da98d6a131bc9354603d82c1e4e3685.6da98d6a.png"},308:function(a,t,s){a.exports=s.p+"assets/img/23292c7eeb0213c66b3751e0113bb97f.23292c7e.png"},309:function(a,t,s){a.exports=s.p+"assets/img/85ae0ef3ad6b0dc2dff15e5063bee7a8.85ae0ef3.png"},310:function(a,t,s){a.exports=s.p+"assets/img/1b4bbe4e5ebdd0df05660bee25abd1c4.1b4bbe4e.png"},584:function(a,t,s){"use strict";s.r(t);var r=s(14),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[a._v("#")]),a._v(" 图")]),a._v(" "),t("h2",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[a._v("#")]),a._v(" 概念")]),a._v(" "),t("p",[t("img",{attrs:{src:s(305),alt:""}})]),a._v(" "),t("p",[a._v("由边和顶点组成")]),a._v(" "),t("p",[a._v("相邻顶点：同一条边的两个顶点")]),a._v(" "),t("p",[a._v("度：相邻顶点的数量，比如 A 的度是 3，B 的度是 2")]),a._v(" "),t("p",[a._v("简单路径：不包含重复顶点的路径，终点和起点可以一致。")]),a._v(" "),t("p",[a._v("比如 A,B,E,I。ACDA")]),a._v(" "),t("p",[a._v("终点和起点一样的叫做环。")]),a._v(" "),t("p",[a._v("如果每两个顶点都存在路径，那么图是连通的")]),a._v(" "),t("p",[t("img",{attrs:{src:s(306),alt:""}})]),a._v(" "),t("h2",{attrs:{id:"图的表示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图的表示"}},[a._v("#")]),a._v(" 图的表示")]),a._v(" "),t("p",[a._v("图的可以用很多类数据结构来表示，根据具体情景来选择合适的数据结构。")]),a._v(" "),t("p",[a._v("矩阵里面存在路径为 1，否则是 0")]),a._v(" "),t("h3",{attrs:{id:"邻接矩阵"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#邻接矩阵"}},[a._v("#")]),a._v(" 邻接矩阵")]),a._v(" "),t("p",[a._v("常用的一种是邻接矩阵（即二维数组）")]),a._v(" "),t("p",[a._v("如果顶点 x 和 y 相邻，那么"),t("code",[a._v("arr[indexX][indexY] = 1")]),a._v("，否则是 0；")]),a._v(" "),t("p",[a._v("弊端：对于不是连通的图，容易浪费空间。")]),a._v(" "),t("p",[t("img",{attrs:{src:s(307),alt:""}})]),a._v(" "),t("h3",{attrs:{id:"邻接表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#邻接表"}},[a._v("#")]),a._v(" 邻接表")]),a._v(" "),t("p",[a._v("可以用数组、链表、字典等表示邻接表")]),a._v(" "),t("p",[t("img",{attrs:{src:s(308),alt:""}})]),a._v(" "),t("h2",{attrs:{id:"遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[a._v("#")]),a._v(" 遍历")]),a._v(" "),t("p",[a._v("广度和深度是针对图/更广泛意义的树来说。先序/中序/后序/层次遍历是针对于二叉树")]),a._v(" "),t("h3",{attrs:{id:"广度优先搜索算法-breadth-first-search-bfs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索算法-breadth-first-search-bfs"}},[a._v("#")]),a._v(" 广度优先搜索算法（Breadth-First-Search，BFS）")]),a._v(" "),t("p",[a._v("先访问同层的全部节点，再访问子节点")]),a._v(" "),t("p",[t("img",{attrs:{src:s(309),alt:""}})]),a._v(" "),t("ol",[t("li",[t("p",[a._v("创建一个队列，将根放入队列")])]),a._v(" "),t("li",[t("p",[a._v("拿出队列的第一个元素，判断是不是目标")])])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("是，返回")])]),a._v(" "),t("li",[t("p",[a._v("不是，把这个元素没检验过的直接子节点放入队列")])])]),a._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("p",[a._v("如果队列空了还没找到目标，那么结束，返回找不到")])]),a._v(" "),t("li",[t("p",[a._v("重复步骤 2")])])]),a._v(" "),t("h3",{attrs:{id:"深度优先-depth-first-search-dfs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深度优先-depth-first-search-dfs"}},[a._v("#")]),a._v(" 深度优先（Depth-first search，DFS）")]),a._v(" "),t("p",[t("img",{attrs:{src:s(310),alt:""}})]),a._v(" "),t("ol",[t("li",[t("p",[a._v("创建一个数组，将根放入队列")])]),a._v(" "),t("li",[t("p",[a._v("拿出队列的第一个元素，判断是不是目标")])])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("是，返回")])]),a._v(" "),t("li",[t("p",[a._v("不是，把这个元素没检验过的直接子节点放入队列")])])]),a._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("p",[a._v("重复步骤 2")])]),a._v(" "),t("li",[t("p",[a._v("如果不存在未检测过的直接子节点，将上一级节点加入队列，重复步骤 2")])]),a._v(" "),t("li",[t("p",[a._v("重复步骤 4")])]),a._v(" "),t("li",[t("p",[a._v("没找到就返回找不到")])])]),a._v(" "),t("h3",{attrs:{id:"最短路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最短路径"}},[a._v("#")]),a._v(" 最短路径")]),a._v(" "),t("h4",{attrs:{id:"戴克斯特拉算法-dijkstra-s-algorithm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#戴克斯特拉算法-dijkstra-s-algorithm"}},[a._v("#")]),a._v(" 戴克斯特拉算法：Dijkstra's algorithm")]),a._v(" "),t("p",[a._v("属于贪心算法")]),a._v(" "),t("p",[a._v("已知起始结点，求最短路径")]),a._v(" "),t("p",[a._v("每个顶点 v 保留目前为止所找到的从 s 到 v 的最短路径")]),a._v(" "),t("h4",{attrs:{id:"floyd-warshall-algorithm-弗洛伊德算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#floyd-warshall-algorithm-弗洛伊德算法"}},[a._v("#")]),a._v(" Floyd-Warshall algorithm（弗洛伊德算法）")]),a._v(" "),t("p",[a._v("属于动态规划算法")]),a._v(" "),t("p",[a._v("任意两点间的最短路径")]),a._v(" "),t("h3",{attrs:{id:"最小生成树-mst"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最小生成树-mst"}},[a._v("#")]),a._v(" 最小生成树（MST）")]),a._v(" "),t("p",[a._v("连接若干个顶点的最短路径")]),a._v(" "),t("h4",{attrs:{id:"prim-算法-普里姆算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prim-算法-普里姆算法"}},[a._v("#")]),a._v(" Prim 算法（普里姆算法）")]),a._v(" "),t("p",[a._v("贪心算法")]),a._v(" "),t("h4",{attrs:{id:"kruskal-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kruskal-算法"}},[a._v("#")]),a._v(" Kruskal 算法")]),a._v(" "),t("p",[a._v("贪心算法")])])}),[],!1,null,null,null);t.default=v.exports}}]);