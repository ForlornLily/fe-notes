(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{654:function(t,_,v){"use strict";v.r(_);var a=v(14),r=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),_("h2",{attrs:{id:"http-的发展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-的发展"}},[t._v("#")]),t._v(" HTTP 的发展")]),t._v(" "),_("p",[t._v("见"),_("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 的发展"),_("OutboundLink")],1),_("br"),t._v("\nHTTP/1.0 开始支持 "),_("code",[t._v("Content-Type")]),t._v("，可以发送除了纯 HTML 文本外的其他内容\nHTTP/1.1 支持请求并发，分块发送，内容协商")]),t._v(" "),_("p",[t._v("HTTP 存在不足之处，主要有")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("通信使用明文（不加密），内容可能会被窃听")])]),t._v(" "),_("li",[_("p",[t._v("不验证通信方的身份，因此有可能遭遇伪装")])]),t._v(" "),_("li",[_("p",[t._v("无法证明报文的完整性，所以有可能已遭篡改")])])]),t._v(" "),_("p",[t._v("SSL（Secure Socket Layer 安全套接层）组合使用 HTTP 就是 HTTPS。")]),t._v(" "),_("p",[t._v("可以对通信进行加密，让 SSL 建立安全线路")]),t._v(" "),_("p",[t._v("还可以使用证书，确认服务端和客户端身份")]),t._v(" "),_("p",[t._v("原本由 HTTP 直接和 TCP 通信，HTTPS 变成 HTTPS 先和 SSL 通信，再由 SSL 和 TCP 通信")]),t._v(" "),_("h2",{attrs:{id:"区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),_("p",[t._v("HTTP 明文传输，HTTPS 加密")]),t._v(" "),_("p",[t._v("HTTP 无状态，默认端口 80")]),t._v(" "),_("p",[t._v("HTTPS 默认端口号 443，以及基于 SSL，更安全")]),t._v(" "),_("p",[t._v("HTTP2 使用的是二进制传送，支持主动向客户端推送内容")]),t._v(" "),_("h2",{attrs:{id:"tls"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tls"}},[t._v("#")]),t._v(" TLS")]),t._v(" "),_("p",[t._v("SSL 的标准")]),t._v(" "),_("p",[t._v("在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。")]),t._v(" "),_("h3",{attrs:{id:"对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[t._v("#")]),t._v(" 对称加密")]),t._v(" "),_("p",[t._v("双向通信：两边拥有相同的秘钥，两边都知道如何将密文加密解密")]),t._v(" "),_("h3",{attrs:{id:"非对称加密"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[t._v("#")]),t._v(" 非对称加密")]),t._v(" "),_("p",[t._v("单向通信：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道")]),t._v(" "),_("h3",{attrs:{id:"tls-1-2-下的握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tls-1-2-下的握手"}},[t._v("#")]),t._v(" TLS 1.2 下的握手")]),t._v(" "),_("p",[t._v("在 TLS 握手阶段，两端使用非对称加密的方式来进行秘钥协商")]),t._v(" "),_("p",[t._v("但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("客户端发送一个随机值，需要的协议和加密方式")])]),t._v(" "),_("li",[_("p",[t._v("服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）")])]),t._v(" "),_("li",[_("p",[t._v("客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书")])]),t._v(" "),_("li",[_("p",[t._v("服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);