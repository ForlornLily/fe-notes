(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{496:function(a,t,e){a.exports=e.p+"assets/img/semispace.da067d53.jpg"},497:function(a,t,e){a.exports=e.p+"assets/img/semi_upgrade.a06f97f2.jpg"},764:function(a,t,e){"use strict";e.r(t);var s=e(14),v=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"v8-中的垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-中的垃圾回收"}},[a._v("#")]),a._v(" V8 中的垃圾回收")]),a._v(" "),t("p",[a._v("随着 NodeJS 在服务端的发展，基于 NodeJS 本身无阻塞、事件驱动建立的服务，具有内存消耗低的特点"),t("br"),a._v("\n适合处理海量的网络请求"),t("br"),a._v("\n在海量请求的前提下，需要考虑一些客户端不太可能造成影响的问题。"),t("br"),a._v("\n内存控制正是在海量请求和长时间运行的前提下要探讨的，如何高效地使用内存，首先要知道 V8 的相关的内存管理")]),a._v(" "),t("h2",{attrs:{id:"v8-的内存限制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-的内存限制"}},[a._v("#")]),a._v(" V8 的内存限制")]),a._v(" "),t("p",[a._v("在 V8 中，所有的对象都是通过堆来进行分配的。\n在 NodeJS 命令行中，输入 "),t("code",[a._v("process.memoryUsage()")]),a._v(" 可以看到当前的内存信息")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" process."),t("span",{pre:!0,attrs:{class:"token function-name function"}},[a._v("memoryUsage")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  rss: "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("19816448")]),a._v(",        "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# rss: resident set size（常驻内存）")]),a._v("\n  heapTotal: "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("5177344")]),a._v(",   "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 已申请到的堆内存")]),a._v("\n  heapUsed: "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2653608")]),a._v(",    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 当前使用量")]),a._v("\n  external: "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1417563")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("                堆\n——————————————————————————————————\n|   已使用对象 |                  |\n——————————————————————————————————\n")])])]),t("p",[a._v("V8 会限制堆的大小，表层原因是因为 V8 最初就是为浏览器设计的，不太可能遇到大内存的场景。"),t("br"),a._v("\n深层原因是因为垃圾回收机制：以 1.5GB 的垃圾回收堆内存为例，做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收，至少需要 1 秒以上。"),t("br"),a._v("\n以上时间指的是引起 JavaScript 线程暂停执行的时间，在这段时间中，应用的性能和响应能力都会直线下降。"),t("br"),a._v("\n在浏览器也是无法接受的，所以不如直接限制堆内存")]),a._v(" "),t("h2",{attrs:{id:"垃圾回收算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[a._v("#")]),a._v(" 垃圾回收算法")]),a._v(" "),t("h3",{attrs:{id:"分代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分代"}},[a._v("#")]),a._v(" 分代")]),a._v(" "),t("p",[a._v("V8 的垃圾回收策略主要基于分代式垃圾回收机制。"),t("br"),a._v("\n按对象的存活时间将内存的的垃圾回收进行不同的分代"),t("br"),a._v("\nV8 中主要分为新生代和老生代两代。")]),a._v(" "),t("ul",[t("li",[a._v("新生代的对象是存活时间较短的对象")]),a._v(" "),t("li",[a._v("老生代是时间较长或者常驻的对象")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("—————————————————————————————————\n|新生代的 |  老生代的内存空间     |\n|内存空间 |                      |\n—————————————————————————————————\n")])])]),t("h3",{attrs:{id:"scavenge-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scavenge-算法"}},[a._v("#")]),a._v(" Scavenge 算法")]),a._v(" "),t("p",[a._v("在分代的基础上，新生代的对象主要通过 Scavenge 算法进行垃圾回收。"),t("br"),a._v("\nScavenge 算法的实现主要采用 Cheney 算法"),t("br"),a._v("\nCheney 算法是一种采用复制的方式实现的垃圾回收算法："),t("br"),a._v("\n将堆内存一分为二，每一部分空间成为 "),t("code",[a._v("semispace")]),a._v("，在这两个空间中，只有一个空间会被使用，另一个处于闲置状态")]),a._v(" "),t("ul",[t("li",[a._v("处于使用状态的 semispace 称为 From 空间")]),a._v(" "),t("li",[a._v("闲置状态称为 To 空间")])]),a._v(" "),t("p",[a._v("当分配对象时，先在 From 空间进行分配。"),t("br"),a._v("\n开始进行垃圾回收时，会检查 From 空间的存活对象，这些存活对象会被复制到 To 空间，而非存活对象则被释放。"),t("br"),a._v("\n完成复制后，原本的 From 空间就成了 To 空间")]),a._v(" "),t("p",[a._v("Scavenge 是典型的用空间换时间的算法，无法大规模地应用到所有垃圾回收中。因为新生代的生命周期较短，比较适合"),t("br"),a._v(" "),t("img",{attrs:{src:e(496),alt:"semispace"}})]),a._v(" "),t("p",[a._v("当一个对象进行多次复制后依然存活，会被认为是生命周期较长的对象。会被移动到老生代的内存空间，采用新的算法进行管理。"),t("br"),a._v("\n从新生到移动到老生代的过程称之为晋升")]),a._v(" "),t("p",[a._v("在单纯的 Scavenge 过程中，From 空间的存活对象会被复制到 To 空间，然后两个空间进行角色交换。"),t("br"),a._v("\n在分代式垃圾回收的前提下，From 的存活对象复制到 To 之前需要进行检查。满足一定条件时要将存活周期长的对象移动到老生代"),t("br"),a._v("\n条件一般分为两部分：")]),a._v(" "),t("ul",[t("li",[a._v("对象是否经历过 Scavenge 回收：通过内存地址来判断\n"),t("img",{attrs:{src:e(497),alt:"晋升过程"}})]),a._v(" "),t("li",[a._v("To 空间的内存占用超过限制：把对一个对象从 From 复制到 To 空间时，如果 To 空间占比超过 25%，直接把该对象晋升到老生代")])]),a._v(" "),t("h3",{attrs:{id:"mark-sweep-mark-compact"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mark-sweep-mark-compact"}},[a._v("#")]),a._v(" Mark-Sweep & Mark-Compact")]),a._v(" "),t("p",[a._v("Scavenge 算法不适合老生代内的对象处理。因为老生代的生命周期比较长\nMark-Sweep：标记-清除"),t("br"),a._v("\n在标记阶段遍历所有对象，并标记活着的对象。然后在清除阶段只清除没有标记的对象")]),a._v(" "),t("p",[a._v("Mark-Sweep 在进行一次标记清除之后，内存会变成不连续的状态。"),t("br"),a._v("\n因为遍历的时候没有修改对象的位置，活着的和未标记的可能是相邻的"),t("br"),a._v("\n这样会对后续的内存分配造成影响。如果需要一个比较大的内存，但是被清除的对象留下的内存都比较小，就不能完成这次分配"),t("br"),a._v("\n所有有了 Mark-Compact：标记-整理。"),t("br"),a._v("\n在标记-清除的基础上，会在遍历的时候把活着的对象往一端移动，清除的时候直接清理掉剩余内存。")]),a._v(" "),t("h3",{attrs:{id:"对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[a._v("#")]),a._v(" 对比")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("回收算法")]),a._v(" "),t("th",[a._v("Mark-Sweep")]),a._v(" "),t("th",[a._v("Mark-Compact")]),a._v(" "),t("th",[a._v("Scavenge")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("速度")]),a._v(" "),t("td",[a._v("中等")]),a._v(" "),t("td",[a._v("最慢")]),a._v(" "),t("td",[a._v("最快")])]),a._v(" "),t("tr",[t("td",[a._v("空间开销")]),a._v(" "),t("td",[a._v("少（有碎片）")]),a._v(" "),t("td",[a._v("少（无碎片）")]),a._v(" "),t("td",[a._v("双倍空间（无碎片）")])]),a._v(" "),t("tr",[t("td",[a._v("是否移动对象")]),a._v(" "),t("td",[a._v("否")]),a._v(" "),t("td",[a._v("是")]),a._v(" "),t("td",[a._v("是")])])])]),a._v(" "),t("p",[a._v("在取舍上，V8 主要用 Mark-Sweep，从新生代晋升到老生代的对象分配内存不足的情况下，使用 Mark-Compact")]),a._v(" "),t("h2",{attrs:{id:"node-中的内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-中的内存"}},[a._v("#")]),a._v(" Node 中的内存")]),a._v(" "),t("p",[a._v("Node 的内存分为通过 V8 分配的部分和 Node 自行分配的部分。"),t("br"),a._v("\n内存限制以及垃圾回收只影响 V8 分配的堆内存。\n因为 V8 本身是为浏览器设计的，JavaScript 大部分情况下处理字符串就满足了。"),t("br"),a._v("\n但 Node 需要处理网络流和文件 I/O 流，所以很多对象是由 Node 自行分配的，比如 Buffer")])])}),[],!1,null,null,null);t.default=v.exports}}]);