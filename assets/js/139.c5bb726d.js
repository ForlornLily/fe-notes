(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{625:function(v,_,t){"use strict";t.r(_);var r=t(14),e=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"常见原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见原则"}},[v._v("#")]),v._v(" 常见原则")]),v._v(" "),_("h2",{attrs:{id:"单一职责原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[v._v("#")]),v._v(" 单一职责原则")]),v._v(" "),_("p",[v._v("SRP: Single responsibility principle"),_("br"),v._v("\n一个对象/方法只做一件事情，避免耦合带来的破坏"),_("br"),v._v("\n实现这一原则的设计模式有：单例模式、代理模式、迭代器模式、装饰器模式")]),v._v(" "),_("ul",[_("li",[v._v("如果一个需求变化，两个职责总是一起变化，那这两个职责没必要分离；")]),v._v(" "),_("li",[v._v("通常情况下的职责都是一一分离的")]),v._v(" "),_("li",[v._v("但从用户层面考虑，有时候违反原来来简化操作也是比较常见的"),_("br"),v._v("\n比如 jQuery 的"),_("code",[v._v("attr")]),v._v(" 方法，既可以取值又可以赋值")])]),v._v(" "),_("h2",{attrs:{id:"最少知识原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最少知识原则"}},[v._v("#")]),v._v(" 最少知识原则")]),v._v(" "),_("p",[v._v("The Principle of Least knowledge，也被称为得墨忒耳定律/迪米特法则 (Law of Demeter)"),_("br"),v._v("\n尽量减少对象之间的交互。"),_("br"),v._v("\n如果两个对象之间没有直接通信，那么这两个对象之间就不要有直接联系"),_("br"),v._v("\n常见的做法是引入第三个对象")]),v._v(" "),_("p",[v._v("实现这一原则的常见模式有：中介者模式")]),v._v(" "),_("h2",{attrs:{id:"开放-封闭原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#开放-封闭原则"}},[v._v("#")]),v._v(" 开放-封闭原则")]),v._v(" "),_("p",[v._v("Open–closed principle"),_("br"),v._v("\n当需要改变一个程序的功能时，使用增加代码的方式，而不是直接修改源码"),_("br"),v._v("\n避免因为修改源码引发新 bug")]),v._v(" "),_("p",[v._v("几乎所有的设计模式都遵循这个原则。但也不是所有功能都可以封闭。合适的方案")]),v._v(" "),_("ul",[_("li",[v._v("挑选出最容器变化的地方，然后构造对象来封闭这些变化")]),v._v(" "),_("li",[v._v("不可避免修改的时候，挑选容易修改的地方。比如使用第三方库时，修改配置文件，而不是直接改源码")])]),v._v(" "),_("p",[v._v("常见手段：")]),v._v(" "),_("ul",[_("li",[v._v("钩子")]),v._v(" "),_("li",[v._v("回调函数：可以认为是特殊的钩子")])])])}),[],!1,null,null,null);_.default=e.exports}}]);