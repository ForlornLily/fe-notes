(window.webpackJsonp=window.webpackJsonp||[]).push([[260],{795:function(v,_,t){"use strict";t.r(_);var a=t(14),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"传输层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#传输层"}},[v._v("#")]),v._v(" 传输层")]),v._v(" "),_("p",[v._v("用于两台计算机之间的数据传输。")]),v._v(" "),_("p",[v._v("传输层有两个不同的协议：TCP 和 UDP")]),v._v(" "),_("h2",{attrs:{id:"udp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[v._v("#")]),v._v(" UDP")]),v._v(" "),_("p",[v._v("UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP\n只是报文的搬运工，不会对报文进行任何拆分和拼接操作")]),v._v(" "),_("p",[v._v("具体来说：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP\n头标识下是 UDP 协议，然后就传递给网络层了")])]),v._v(" "),_("li",[_("p",[v._v("在接收端，网络层将数据传递给传输层，UDP 只去除 IP\n报文头就传递给应用层，不会任何拼接操作")])])]),v._v(" "),_("h3",{attrs:{id:"特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[v._v("#")]),v._v(" 特性")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("无连接的，也就是说通信不需要建立和断开连接")])]),v._v(" "),_("li",[_("p",[v._v("不可靠的，收到什么数据就传递什么，不会备份，也不关心对方收到没")])]),v._v(" "),_("li",[_("p",[v._v("没有拥塞机制，当网络条件不好的时候可能丢包比较严重。但是因此实时性强（比如用在电话会议）")])]),v._v(" "),_("li",[_("p",[v._v("头部信息少，开销小")])]),v._v(" "),_("li",[_("p",[v._v("支持一对多，多对一，多对多的传输方式")])])]),v._v(" "),_("h2",{attrs:{id:"tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[v._v("#")]),v._v(" TCP")]),v._v(" "),_("p",[v._v("提供可靠的字节流服务（Byte Stream Service）。")]),v._v(" "),_("p",[v._v("可靠：确保传送给对方")]),v._v(" "),_("p",[v._v("字节流服务：将大数据以报文段（segment）为单位进行管理")]),v._v(" "),_("p",[v._v("也就是 TCP 协议为了更容易传送大数据进行了数据分割，同时 TCP 协议能够确保数据是否传送给对方。也就只能一对一")]),v._v(" "),_("p",[v._v("为了确保能够准确无误地传送给对方，用了三次握手(three-way handshaking)策略")]),v._v(" "),_("h3",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[v._v("#")]),v._v(" 三次握手")]),v._v(" "),_("p",[v._v("为了确保传送给对方的手段")]),v._v(" "),_("p",[v._v("使用两个标志：SYN（synchronize）和 ACK（acknowledgement）")]),v._v(" "),_("p",[v._v("发送端发送 SYN 给接收端 → 接收端接受后，回传 SYN+ACK 表示确认信息 → 发送端发送带 ACK 标志的数据包，握手结束"),_("br"),v._v("\nSYN 是建立连接"),_("br"),v._v("\nACK 是为了保证建立的是同一个连接")]),v._v(" "),_("h3",{attrs:{id:"原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[v._v("#")]),v._v(" 原因")]),v._v(" "),_("p",[v._v("确保双端"),_("strong",[v._v("发送")]),v._v("和"),_("strong",[v._v("接收")]),v._v("两个功能都要正常"),_("br"),v._v("\n自己确认自己两个功能；对方确认自己两个功能")]),v._v(" "),_("ol",[_("li",[v._v("第一次：客户端发送\n"),_("ul",[_("li",[v._v("客户端无法确认服务器状态，只能确认自己发送正常；")]),v._v(" "),_("li",[v._v("服务器只能确认自己接收正常")])])]),v._v(" "),_("li",[v._v("第二次：服务器发送\n"),_("ul",[_("li",[v._v("服务器确认了客户端的发送正常；确认自己发送正常")]),v._v(" "),_("li",[v._v("客户端确认了服务器的发送、接收都正常；确认自己接收正常。")])])]),v._v(" "),_("li",[v._v("第三次：服务器确认了客户端的接收也是正常的")])]),v._v(" "),_("h3",{attrs:{id:"断开连接时的四次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#断开连接时的四次握手"}},[v._v("#")]),v._v(" 断开连接时的四次握手")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求（FIN）")])]),v._v(" "),_("li",[_("p",[v._v("B 收到 FIN 后，会发送 ACK 进行确认")])]),v._v(" "),_("li",[_("p",[v._v("仍然是 B。B 将所有数据发送结束，发送 FIN")])])]),v._v(" "),_("p",[v._v("4.A 接收到 FIN，发送 ACK 表示彻底释放")]),v._v(" "),_("p",[v._v("类似打电话")]),v._v(" "),_("ol",[_("li",[v._v('A 说"我要挂了"')]),v._v(" "),_("li",[v._v('B 说"好的"')]),v._v(" "),_("li",[v._v("然后 B 可能还有要说的，继续说完")]),v._v(" "),_("li",[v._v('A 等 B 说完，"说完了吧，我挂了"')])])])}),[],!1,null,null,null);_.default=r.exports}}]);