(window.webpackJsonp=window.webpackJsonp||[]).push([[250],{783:function(t,e,r){"use strict";r.r(e);var a=r(14),_=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),e("p",[t._v("相关地址")]),t._v(" "),e("ul",[e("li",[t._v("性能检测"),e("a",{attrs:{href:"https://reactjs.org/docs/optimizing-performance.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Optimizing Performance"),e("OutboundLink")],1)]),t._v(" "),e("li",[t._v("diff 算法"),e("a",{attrs:{href:"https://reactjs.org/docs/reconciliation.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Reconciliation"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"概要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概要"}},[t._v("#")]),t._v(" 概要")]),t._v(" "),e("ol",[e("li",[t._v("不同类型的元素生成不同的树")]),t._v(" "),e("li",[t._v("通过 "),e("code",[t._v("key")]),t._v(" 属性表明哪些子元素在不同的渲染中也是不变的")])]),t._v(" "),e("h2",{attrs:{id:"diff-算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[t._v("#")]),t._v(" diff 算法")]),t._v(" "),e("p",[t._v("只对比同层，不同层级的节点，只有创建和删除操作"),e("br"),t._v("\n对比两颗树时，最先对比的是两个根元素")]),t._v(" "),e("ul",[e("li",[t._v("如果两个根元素类型不同，直接销毁旧的 DOM，渲染新 DOM，对应旧的（包括子元素）所有 state 会丢失")]),t._v(" "),e("li",[t._v("两个元素类型相同，会保留相同的属性（attribute），只更新改变的属性。处理完之后对子节点进行递归")])]),t._v(" "),e("p",[t._v("当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A （包括子节点）作为其子节点")]),t._v(" "),e("h3",{attrs:{id:"key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#key"}},[t._v("#")]),t._v(" key")]),t._v(" "),e("p",[t._v("存在 "),e("code",[t._v("key")]),t._v(" 时，React 会对比具有相同 "),e("code",[t._v("key")]),t._v(" 的新旧节点")])])}),[],!1,null,null,null);e.default=_.exports}}]);